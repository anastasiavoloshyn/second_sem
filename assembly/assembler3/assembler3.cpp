#include <iostream>

int main()
{
    int a = 1;
    int y1, y2;
    int* values = new int[5];
    int x = -2;
    int _3 = 3;
    __asm {
        jmp start
        //функція для обчислення модулю
        abs1 :
        test eax, eax           //аргумент "функції" передається через eax
            js negative         //перевіряю чи аргумент є від'ємним, якщо так перехожу до інструкції negative
            ret                 //якщо ні то функція завершує свою роботу
            negative :
            neg eax             //змінюю знак аргументу у випадку коли він від'ємний
            ret         
            start :
        mov ecx, values         //зберігаю вказівник на поточний елемент масиву в регістр ecx
            mov ebx, x          //зберігаю зміну Х в регістрі ebx
            loop_start :
        cmp ebx, 0              //порівнюю X з нулем за умовою завд
            jl y1_c1            // якщо X<0 перехожу до інструкції y1_c1
            jmp y1_c2           // "безумовний стрибок" до інструкції y1-c2, якщо X>=0
            y1_c1 :             //якщо Х<0
        mov eax, ebx            //передаємо Х в функцію модулю
            call abs1           //викликаю функцію модулю
            mov y1, eax         //записуємо y1 в регістр
        jmp y2_calc             //стрибаємо до інструкції обрахунку y2
            y1_c2 :             //якщо X>=0
        mov eax, ebx            //будемо віднімати від Х
            sub eax, a         
            mov y1, eax         //записую результат в зміну y1
            jmp y2_calc         // перехожу до обрахунків у2
            y2_calc :           //інструкція для обрахунку y2
        mov eax, ebx            // будемо ділити на X
            cdq                 //розширюю регістр для запису результатів ділення (eax:edx)
            idiv _3             // ділимо X/3
            cmp edx, 1          //порівнюю остачу що лишилась від ділення з 1 за умовою завд
            je y2_c1            //якщо Xmod3 = 1, перехожу до інструкції y2_c1
            jmp y2_c2           //якщо Хmod3!=1, перехожу до інструкції y2_c2
            y2_c1 :             //якщо Xmod3 = 1
        mov eax, ebx            // буду додавати до Х
            add eax, a          
            mov y2, eax         //зберігаю результат в зміну у2
            jmp loop_end        //стрибаю в кінець ітерації
            y2_c2 :             //якщо Хmod3!=1
        mov eax, 7
            mov y2, eax         //результат = 7,(за умовою), якщо Хmod3!=1, зберігаю його в зміну у2
            jmp loop_end
            loop_end :
        mov eax, y1             // будемо віднімати від у1
            sub eax, y2         // обраховуємо у1 - у2
            mov[ecx], eax       //результат записою за адресою вказівника з динамічного масиву
            add ecx, 4          //перехожу на наступний елемент масиву, додаючи 4 байти(пам'ять яку займає int)
            add ebx, 1          // ++x
            cmp ebx, 3          //порівнюю X з 3(x є [-2,2])
            jl loop_start       //якщо Х<3, проходимося по циклу ще раз (xє[-2,2])
    }
    std::cout << "Result assembler:";
    for (int i = 0; i < 5; ++i) {
        std::cout << values[i] << " ";
    }
    std::cout << "\nResult c++:";
    for (int i = -2; i < 3; ++i) {
        if (i < 0) {
            y1 = abs(i);
        }
        else {
            y1 = i - a;                 //переівіряю коректність роботи коду асемблера
        }
        if (i % 3 == 1) {
            y2 = i + a;
        }
        else {
            y2 = 7;
        }
        std::cout << y1 - y2 << " ";
    }
    return 0;
}
